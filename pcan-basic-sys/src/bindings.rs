/* automatically generated by rust-bindgen 0.59.1 */

pub const PCAN_NONEBUS: u32 = 0;
pub const PCAN_ISABUS1: u32 = 33;
pub const PCAN_ISABUS2: u32 = 34;
pub const PCAN_ISABUS3: u32 = 35;
pub const PCAN_ISABUS4: u32 = 36;
pub const PCAN_ISABUS5: u32 = 37;
pub const PCAN_ISABUS6: u32 = 38;
pub const PCAN_ISABUS7: u32 = 39;
pub const PCAN_ISABUS8: u32 = 40;
pub const PCAN_DNGBUS1: u32 = 49;
pub const PCAN_PCIBUS1: u32 = 65;
pub const PCAN_PCIBUS2: u32 = 66;
pub const PCAN_PCIBUS3: u32 = 67;
pub const PCAN_PCIBUS4: u32 = 68;
pub const PCAN_PCIBUS5: u32 = 69;
pub const PCAN_PCIBUS6: u32 = 70;
pub const PCAN_PCIBUS7: u32 = 71;
pub const PCAN_PCIBUS8: u32 = 72;
pub const PCAN_PCIBUS9: u32 = 1033;
pub const PCAN_PCIBUS10: u32 = 1034;
pub const PCAN_PCIBUS11: u32 = 1035;
pub const PCAN_PCIBUS12: u32 = 1036;
pub const PCAN_PCIBUS13: u32 = 1037;
pub const PCAN_PCIBUS14: u32 = 1038;
pub const PCAN_PCIBUS15: u32 = 1039;
pub const PCAN_PCIBUS16: u32 = 1040;
pub const PCAN_USBBUS1: u32 = 81;
pub const PCAN_USBBUS2: u32 = 82;
pub const PCAN_USBBUS3: u32 = 83;
pub const PCAN_USBBUS4: u32 = 84;
pub const PCAN_USBBUS5: u32 = 85;
pub const PCAN_USBBUS6: u32 = 86;
pub const PCAN_USBBUS7: u32 = 87;
pub const PCAN_USBBUS8: u32 = 88;
pub const PCAN_USBBUS9: u32 = 1289;
pub const PCAN_USBBUS10: u32 = 1290;
pub const PCAN_USBBUS11: u32 = 1291;
pub const PCAN_USBBUS12: u32 = 1292;
pub const PCAN_USBBUS13: u32 = 1293;
pub const PCAN_USBBUS14: u32 = 1294;
pub const PCAN_USBBUS15: u32 = 1295;
pub const PCAN_USBBUS16: u32 = 1296;
pub const PCAN_PCCBUS1: u32 = 97;
pub const PCAN_PCCBUS2: u32 = 98;
pub const PCAN_LANBUS1: u32 = 2049;
pub const PCAN_LANBUS2: u32 = 2050;
pub const PCAN_LANBUS3: u32 = 2051;
pub const PCAN_LANBUS4: u32 = 2052;
pub const PCAN_LANBUS5: u32 = 2053;
pub const PCAN_LANBUS6: u32 = 2054;
pub const PCAN_LANBUS7: u32 = 2055;
pub const PCAN_LANBUS8: u32 = 2056;
pub const PCAN_LANBUS9: u32 = 2057;
pub const PCAN_LANBUS10: u32 = 2058;
pub const PCAN_LANBUS11: u32 = 2059;
pub const PCAN_LANBUS12: u32 = 2060;
pub const PCAN_LANBUS13: u32 = 2061;
pub const PCAN_LANBUS14: u32 = 2062;
pub const PCAN_LANBUS15: u32 = 2063;
pub const PCAN_LANBUS16: u32 = 2064;
pub const PCAN_ERROR_OK: u32 = 0;
pub const PCAN_ERROR_XMTFULL: u32 = 1;
pub const PCAN_ERROR_OVERRUN: u32 = 2;
pub const PCAN_ERROR_BUSLIGHT: u32 = 4;
pub const PCAN_ERROR_BUSHEAVY: u32 = 8;
pub const PCAN_ERROR_BUSWARNING: u32 = 8;
pub const PCAN_ERROR_BUSPASSIVE: u32 = 262144;
pub const PCAN_ERROR_BUSOFF: u32 = 16;
pub const PCAN_ERROR_ANYBUSERR: u32 = 262172;
pub const PCAN_ERROR_QRCVEMPTY: u32 = 32;
pub const PCAN_ERROR_QOVERRUN: u32 = 64;
pub const PCAN_ERROR_QXMTFULL: u32 = 128;
pub const PCAN_ERROR_REGTEST: u32 = 256;
pub const PCAN_ERROR_NODRIVER: u32 = 512;
pub const PCAN_ERROR_HWINUSE: u32 = 1024;
pub const PCAN_ERROR_NETINUSE: u32 = 2048;
pub const PCAN_ERROR_ILLHW: u32 = 5120;
pub const PCAN_ERROR_ILLNET: u32 = 6144;
pub const PCAN_ERROR_ILLCLIENT: u32 = 7168;
pub const PCAN_ERROR_ILLHANDLE: u32 = 7168;
pub const PCAN_ERROR_RESOURCE: u32 = 8192;
pub const PCAN_ERROR_ILLPARAMTYPE: u32 = 16384;
pub const PCAN_ERROR_ILLPARAMVAL: u32 = 32768;
pub const PCAN_ERROR_UNKNOWN: u32 = 65536;
pub const PCAN_ERROR_ILLDATA: u32 = 131072;
pub const PCAN_ERROR_ILLMODE: u32 = 524288;
pub const PCAN_ERROR_CAUTION: u32 = 33554432;
pub const PCAN_ERROR_INITIALIZE: u32 = 67108864;
pub const PCAN_ERROR_ILLOPERATION: u32 = 134217728;
pub const PCAN_NONE: u32 = 0;
pub const PCAN_PEAKCAN: u32 = 1;
pub const PCAN_ISA: u32 = 2;
pub const PCAN_DNG: u32 = 3;
pub const PCAN_PCI: u32 = 4;
pub const PCAN_USB: u32 = 5;
pub const PCAN_PCC: u32 = 6;
pub const PCAN_VIRTUAL: u32 = 7;
pub const PCAN_LAN: u32 = 8;
pub const PCAN_DEVICE_ID: u32 = 1;
pub const PCAN_5VOLTS_POWER: u32 = 2;
pub const PCAN_RECEIVE_EVENT: u32 = 3;
pub const PCAN_MESSAGE_FILTER: u32 = 4;
pub const PCAN_API_VERSION: u32 = 5;
pub const PCAN_CHANNEL_VERSION: u32 = 6;
pub const PCAN_BUSOFF_AUTORESET: u32 = 7;
pub const PCAN_LISTEN_ONLY: u32 = 8;
pub const PCAN_LOG_LOCATION: u32 = 9;
pub const PCAN_LOG_STATUS: u32 = 10;
pub const PCAN_LOG_CONFIGURE: u32 = 11;
pub const PCAN_LOG_TEXT: u32 = 12;
pub const PCAN_CHANNEL_CONDITION: u32 = 13;
pub const PCAN_HARDWARE_NAME: u32 = 14;
pub const PCAN_RECEIVE_STATUS: u32 = 15;
pub const PCAN_CONTROLLER_NUMBER: u32 = 16;
pub const PCAN_TRACE_LOCATION: u32 = 17;
pub const PCAN_TRACE_STATUS: u32 = 18;
pub const PCAN_TRACE_SIZE: u32 = 19;
pub const PCAN_TRACE_CONFIGURE: u32 = 20;
pub const PCAN_CHANNEL_IDENTIFYING: u32 = 21;
pub const PCAN_CHANNEL_FEATURES: u32 = 22;
pub const PCAN_BITRATE_ADAPTING: u32 = 23;
pub const PCAN_BITRATE_INFO: u32 = 24;
pub const PCAN_BITRATE_INFO_FD: u32 = 25;
pub const PCAN_BUSSPEED_NOMINAL: u32 = 26;
pub const PCAN_BUSSPEED_DATA: u32 = 27;
pub const PCAN_IP_ADDRESS: u32 = 28;
pub const PCAN_LAN_SERVICE_STATUS: u32 = 29;
pub const PCAN_ALLOW_STATUS_FRAMES: u32 = 30;
pub const PCAN_ALLOW_RTR_FRAMES: u32 = 31;
pub const PCAN_ALLOW_ERROR_FRAMES: u32 = 32;
pub const PCAN_INTERFRAME_DELAY: u32 = 33;
pub const PCAN_ACCEPTANCE_FILTER_11BIT: u32 = 34;
pub const PCAN_ACCEPTANCE_FILTER_29BIT: u32 = 35;
pub const PCAN_IO_DIGITAL_CONFIGURATION: u32 = 36;
pub const PCAN_IO_DIGITAL_VALUE: u32 = 37;
pub const PCAN_IO_DIGITAL_SET: u32 = 38;
pub const PCAN_IO_DIGITAL_CLEAR: u32 = 39;
pub const PCAN_IO_ANALOG_VALUE: u32 = 40;
pub const PCAN_FIRMWARE_VERSION: u32 = 41;
pub const PCAN_ATTACHED_CHANNELS_COUNT: u32 = 42;
pub const PCAN_ATTACHED_CHANNELS: u32 = 43;
pub const PCAN_DEVICE_NUMBER: u32 = 1;
pub const PCAN_PARAMETER_OFF: u32 = 0;
pub const PCAN_PARAMETER_ON: u32 = 1;
pub const PCAN_FILTER_CLOSE: u32 = 0;
pub const PCAN_FILTER_OPEN: u32 = 1;
pub const PCAN_FILTER_CUSTOM: u32 = 2;
pub const PCAN_CHANNEL_UNAVAILABLE: u32 = 0;
pub const PCAN_CHANNEL_AVAILABLE: u32 = 1;
pub const PCAN_CHANNEL_OCCUPIED: u32 = 2;
pub const PCAN_CHANNEL_PCANVIEW: u32 = 3;
pub const LOG_FUNCTION_DEFAULT: u32 = 0;
pub const LOG_FUNCTION_ENTRY: u32 = 1;
pub const LOG_FUNCTION_PARAMETERS: u32 = 2;
pub const LOG_FUNCTION_LEAVE: u32 = 4;
pub const LOG_FUNCTION_WRITE: u32 = 8;
pub const LOG_FUNCTION_READ: u32 = 16;
pub const LOG_FUNCTION_ALL: u32 = 65535;
pub const TRACE_FILE_SINGLE: u32 = 0;
pub const TRACE_FILE_SEGMENTED: u32 = 1;
pub const TRACE_FILE_DATE: u32 = 2;
pub const TRACE_FILE_TIME: u32 = 4;
pub const TRACE_FILE_OVERWRITE: u32 = 128;
pub const FEATURE_FD_CAPABLE: u32 = 1;
pub const FEATURE_DELAY_CAPABLE: u32 = 2;
pub const FEATURE_IO_CAPABLE: u32 = 4;
pub const SERVICE_STATUS_STOPPED: u32 = 1;
pub const SERVICE_STATUS_RUNNING: u32 = 4;
pub const MAX_LENGTH_HARDWARE_NAME: u32 = 33;
pub const MAX_LENGTH_VERSION_STRING: u32 = 18;
pub const PCAN_MESSAGE_STANDARD: u32 = 0;
pub const PCAN_MESSAGE_RTR: u32 = 1;
pub const PCAN_MESSAGE_EXTENDED: u32 = 2;
pub const PCAN_MESSAGE_FD: u32 = 4;
pub const PCAN_MESSAGE_BRS: u32 = 8;
pub const PCAN_MESSAGE_ESI: u32 = 16;
pub const PCAN_MESSAGE_ERRFRAME: u32 = 64;
pub const PCAN_MESSAGE_STATUS: u32 = 128;
pub const PCAN_MODE_STANDARD: u32 = 0;
pub const PCAN_MODE_EXTENDED: u32 = 2;
pub const PCAN_BAUD_1M: u32 = 20;
pub const PCAN_BAUD_800K: u32 = 22;
pub const PCAN_BAUD_500K: u32 = 28;
pub const PCAN_BAUD_250K: u32 = 284;
pub const PCAN_BAUD_125K: u32 = 796;
pub const PCAN_BAUD_100K: u32 = 17199;
pub const PCAN_BAUD_95K: u32 = 49998;
pub const PCAN_BAUD_83K: u32 = 34091;
pub const PCAN_BAUD_50K: u32 = 18223;
pub const PCAN_BAUD_47K: u32 = 5140;
pub const PCAN_BAUD_33K: u32 = 35631;
pub const PCAN_BAUD_20K: u32 = 21295;
pub const PCAN_BAUD_10K: u32 = 26415;
pub const PCAN_BAUD_5K: u32 = 32639;
pub const PCAN_TYPE_ISA: u32 = 1;
pub const PCAN_TYPE_ISA_SJA: u32 = 9;
pub const PCAN_TYPE_ISA_PHYTEC: u32 = 4;
pub const PCAN_TYPE_DNG: u32 = 2;
pub const PCAN_TYPE_DNG_EPP: u32 = 3;
pub const PCAN_TYPE_DNG_SJA: u32 = 5;
pub const PCAN_TYPE_DNG_SJA_EPP: u32 = 6;
pub type BYTE = ::std::os::raw::c_uchar;
pub type CHAR = ::std::os::raw::c_char;
pub type WORD = ::std::os::raw::c_ushort;
pub type DWORD = ::std::os::raw::c_ulong;
pub type UINT64 = ::std::os::raw::c_ulonglong;
pub type LPSTR = *mut CHAR;
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagTPCANMsg {
    pub ID: DWORD,
    pub MSGTYPE: BYTE,
    pub LEN: BYTE,
    pub DATA: [BYTE; 8usize],
}
#[test]
fn bindgen_test_layout_tagTPCANMsg() {
    assert_eq!(
        ::std::mem::size_of::<tagTPCANMsg>(),
        16usize,
        concat!("Size of: ", stringify!(tagTPCANMsg))
    );
    assert_eq!(
        ::std::mem::align_of::<tagTPCANMsg>(),
        4usize,
        concat!("Alignment of ", stringify!(tagTPCANMsg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagTPCANMsg>())).ID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTPCANMsg),
            "::",
            stringify!(ID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagTPCANMsg>())).MSGTYPE as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTPCANMsg),
            "::",
            stringify!(MSGTYPE)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagTPCANMsg>())).LEN as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTPCANMsg),
            "::",
            stringify!(LEN)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagTPCANMsg>())).DATA as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTPCANMsg),
            "::",
            stringify!(DATA)
        )
    );
}
#[doc = ""]
pub type TPCANMsg = tagTPCANMsg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagTPCANTimestamp {
    pub millis: DWORD,
    pub millis_overflow: WORD,
    pub micros: WORD,
}
#[test]
fn bindgen_test_layout_tagTPCANTimestamp() {
    assert_eq!(
        ::std::mem::size_of::<tagTPCANTimestamp>(),
        8usize,
        concat!("Size of: ", stringify!(tagTPCANTimestamp))
    );
    assert_eq!(
        ::std::mem::align_of::<tagTPCANTimestamp>(),
        4usize,
        concat!("Alignment of ", stringify!(tagTPCANTimestamp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagTPCANTimestamp>())).millis as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTPCANTimestamp),
            "::",
            stringify!(millis)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tagTPCANTimestamp>())).millis_overflow as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTPCANTimestamp),
            "::",
            stringify!(millis_overflow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagTPCANTimestamp>())).micros as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTPCANTimestamp),
            "::",
            stringify!(micros)
        )
    );
}
pub type TPCANTimestamp = tagTPCANTimestamp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagTPCANMsgFD {
    pub ID: DWORD,
    pub MSGTYPE: BYTE,
    pub DLC: BYTE,
    pub DATA: [BYTE; 64usize],
}
#[test]
fn bindgen_test_layout_tagTPCANMsgFD() {
    assert_eq!(
        ::std::mem::size_of::<tagTPCANMsgFD>(),
        72usize,
        concat!("Size of: ", stringify!(tagTPCANMsgFD))
    );
    assert_eq!(
        ::std::mem::align_of::<tagTPCANMsgFD>(),
        4usize,
        concat!("Alignment of ", stringify!(tagTPCANMsgFD))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagTPCANMsgFD>())).ID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTPCANMsgFD),
            "::",
            stringify!(ID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagTPCANMsgFD>())).MSGTYPE as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTPCANMsgFD),
            "::",
            stringify!(MSGTYPE)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagTPCANMsgFD>())).DLC as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTPCANMsgFD),
            "::",
            stringify!(DLC)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagTPCANMsgFD>())).DATA as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTPCANMsgFD),
            "::",
            stringify!(DATA)
        )
    );
}
pub type TPCANMsgFD = tagTPCANMsgFD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagTPCANChannelInformation {
    pub channel_handle: WORD,
    pub device_type: BYTE,
    pub controller_number: BYTE,
    pub device_features: DWORD,
    pub device_name: [::std::os::raw::c_char; 33usize],
    pub device_id: DWORD,
    pub channel_condition: DWORD,
}
#[test]
fn bindgen_test_layout_tagTPCANChannelInformation() {
    assert_eq!(
        ::std::mem::size_of::<tagTPCANChannelInformation>(),
        52usize,
        concat!("Size of: ", stringify!(tagTPCANChannelInformation))
    );
    assert_eq!(
        ::std::mem::align_of::<tagTPCANChannelInformation>(),
        4usize,
        concat!("Alignment of ", stringify!(tagTPCANChannelInformation))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tagTPCANChannelInformation>())).channel_handle as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTPCANChannelInformation),
            "::",
            stringify!(channel_handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tagTPCANChannelInformation>())).device_type as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTPCANChannelInformation),
            "::",
            stringify!(device_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tagTPCANChannelInformation>())).controller_number as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTPCANChannelInformation),
            "::",
            stringify!(controller_number)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tagTPCANChannelInformation>())).device_features as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTPCANChannelInformation),
            "::",
            stringify!(device_features)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tagTPCANChannelInformation>())).device_name as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTPCANChannelInformation),
            "::",
            stringify!(device_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tagTPCANChannelInformation>())).device_id as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTPCANChannelInformation),
            "::",
            stringify!(device_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tagTPCANChannelInformation>())).channel_condition as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tagTPCANChannelInformation),
            "::",
            stringify!(channel_condition)
        )
    );
}
pub type TPCANChannelInformation = tagTPCANChannelInformation;
extern "C" {
    #[doc = " <summary>"]
    #[doc = " Initializes a PCAN Channel"]
    #[doc = " </summary>"]
    #[doc = " <param name=\"Channel\">\"The handle of a PCAN Channel\"</param>"]
    #[doc = " <param name=\"Btr0Btr1\">\"The speed for the communication (BTR0BTR1 code)\"</param>"]
    #[doc = " <param name=\"HwType\">\"Non-PnP: The type of hardware and operation mode\"</param>"]
    #[doc = " <param name=\"IOPort\">\"Non-PnP: The I/O address for the parallel port\"</param>"]
    #[doc = " <param name=\"Interrupt\">\"Non-PnP: Interrupt number of the parallel port\"</param>"]
    #[doc = " <returns>\"A TPCANStatus error code\"</returns>"]
    pub fn CAN_Initialize(
        Channel: WORD,
        Btr0Btr1: WORD,
        HwType: BYTE,
        IOPort: DWORD,
        Interrupt: WORD,
    ) -> DWORD;
}
extern "C" {
    #[doc = " <example>f_clock=80000000,nom_brp=10,nom_tseg1=5,nom_tseg2=2,nom_sjw=1,data_brp=4,data_tseg1=7,data_tseg2=2,data_sjw=1</example>"]
    #[doc = " <returns>\"A TPCANStatus error code\"</returns>"]
    pub fn CAN_InitializeFD(Channel: WORD, BitrateFD: LPSTR) -> DWORD;
}
extern "C" {
    #[doc = " <summary>"]
    #[doc = " Uninitializes one or all PCAN Channels initialized by CAN_Initialize"]
    #[doc = " </summary>"]
    #[doc = " <remarks>Giving the TPCANHandle value \"PCAN_NONEBUS\","]
    #[doc = " uninitialize all initialized channels</remarks>"]
    #[doc = " <param name=\"Channel\">\"The handle of a PCAN Channel\"</param>"]
    #[doc = " <returns>\"A TPCANStatus error code\"</returns>"]
    pub fn CAN_Uninitialize(Channel: WORD) -> DWORD;
}
extern "C" {
    #[doc = " <summary>"]
    #[doc = " Resets the receive and transmit queues of the PCAN Channel"]
    #[doc = " </summary>"]
    #[doc = " <remarks>"]
    #[doc = " A reset of the CAN controller is not performed."]
    #[doc = " </remarks>"]
    #[doc = " <param name=\"Channel\">\"The handle of a PCAN Channel\"</param>"]
    #[doc = " <returns>\"A TPCANStatus error code\"</returns>"]
    pub fn CAN_Reset(Channel: WORD) -> DWORD;
}
extern "C" {
    #[doc = " <summary>"]
    #[doc = " Gets the current status of a PCAN Channel"]
    #[doc = " </summary>"]
    #[doc = " <param name=\"Channel\">\"The handle of a PCAN Channel\"</param>"]
    #[doc = " <returns>\"A TPCANStatus error code\"</returns>"]
    pub fn CAN_GetStatus(Channel: WORD) -> DWORD;
}
extern "C" {
    #[doc = " <summary>"]
    #[doc = " Reads a CAN message from the receive queue of a PCAN Channel"]
    #[doc = " </summary>"]
    #[doc = " <param name=\"Channel\">\"The handle of a PCAN Channel\"</param>"]
    #[doc = " <param name=\"MessageBuffer\">\"A TPCANMsg structure buffer to store the CAN message\"</param>"]
    #[doc = " <param name=\"TimestampBuffer\">\"A TPCANTimestamp structure buffer to get"]
    #[doc = " the reception time of the message. If this value is not desired, this parameter"]
    #[doc = " should be passed as NULL\"</param>"]
    #[doc = " <returns>\"A TPCANStatus error code\"</returns>"]
    pub fn CAN_Read(
        Channel: WORD,
        MessageBuffer: *mut TPCANMsg,
        TimestampBuffer: *mut TPCANTimestamp,
    ) -> DWORD;
}
extern "C" {
    #[doc = " <summary>"]
    #[doc = " Reads a CAN message from the receive queue of a FD capable PCAN Channel"]
    #[doc = " </summary>"]
    #[doc = " <param name=\"Channel\">\"The handle of a FD capable PCAN Channel\"</param>"]
    #[doc = " <param name=\"MessageBuffer\">\"A TPCANMsgFD structure buffer to store the CAN message\"</param>"]
    #[doc = " <param name=\"TimestampBuffer\">\"A TPCANTimestampFD buffer to get"]
    #[doc = " the reception time of the message. If this value is not desired, this parameter"]
    #[doc = " should be passed as NULL\"</param>"]
    #[doc = " <returns>\"A TPCANStatus error code\"</returns>"]
    pub fn CAN_ReadFD(
        Channel: WORD,
        MessageBuffer: *mut TPCANMsgFD,
        TimestampBuffer: *mut UINT64,
    ) -> DWORD;
}
extern "C" {
    #[doc = " <summary>"]
    #[doc = " Transmits a CAN message"]
    #[doc = " </summary>"]
    #[doc = " <param name=\"Channel\">\"The handle of a PCAN Channel\"</param>"]
    #[doc = " <param name=\"MessageBuffer\">\"A TPCANMsg buffer with the message to be sent\"</param>"]
    #[doc = " <returns>\"A TPCANStatus error code\"</returns>"]
    pub fn CAN_Write(Channel: WORD, MessageBuffer: *mut TPCANMsg) -> DWORD;
}
extern "C" {
    #[doc = " <summary>"]
    #[doc = " Transmits a CAN message over a FD capable PCAN Channel"]
    #[doc = " </summary>"]
    #[doc = " <param name=\"Channel\">\"The handle of a FD capable PCAN Channel\"</param>"]
    #[doc = " <param name=\"MessageBuffer\">\"A TPCANMsgFD buffer with the message to be sent\"</param>"]
    #[doc = " <returns>\"A TPCANStatus error code\"</returns>"]
    pub fn CAN_WriteFD(Channel: WORD, MessageBuffer: *mut TPCANMsgFD) -> DWORD;
}
extern "C" {
    #[doc = " <summary>"]
    #[doc = " Configures the reception filter."]
    #[doc = " </summary>"]
    #[doc = " <remarks>The message filter will be expanded with every call to"]
    #[doc = " this function. If it is desired to reset the filter, please use"]
    #[doc = " the CAN_SetValue function</remarks>"]
    #[doc = " <param name=\"Channel\">\"The handle of a PCAN Channel\"</param>"]
    #[doc = " <param name=\"FromID\">\"The lowest CAN ID to be received\"</param>"]
    #[doc = " <param name=\"ToID\">\"The highest CAN ID to be received\"</param>"]
    #[doc = " <param name=\"Mode\">\"Message type, Standard (11-bit identifier) or"]
    #[doc = " Extended (29-bit identifier)\"</param>"]
    #[doc = " <returns>\"A TPCANStatus error code\"</returns>"]
    pub fn CAN_FilterMessages(Channel: WORD, FromID: DWORD, ToID: DWORD, Mode: BYTE) -> DWORD;
}
extern "C" {
    #[doc = " <summary>"]
    #[doc = " Retrieves a PCAN Channel value"]
    #[doc = " </summary>"]
    #[doc = " <remarks>Parameters can be present or not according with the kind"]
    #[doc = " of Hardware (PCAN Channel) being used. If a parameter is not available,"]
    #[doc = " a PCAN_ERROR_ILLPARAMTYPE error will be returned</remarks>"]
    #[doc = " <param name=\"Channel\">\"The handle of a PCAN Channel\"</param>"]
    #[doc = " <param name=\"Parameter\">\"The TPCANParameter parameter to get\"</param>"]
    #[doc = " <param name=\"Buffer\">\"Buffer for the parameter value\"</param>"]
    #[doc = " <param name=\"BufferLength\">\"Size in bytes of the buffer\"</param>"]
    #[doc = " <returns>\"A TPCANStatus error code\"</returns>"]
    pub fn CAN_GetValue(
        Channel: WORD,
        Parameter: BYTE,
        Buffer: *mut ::std::os::raw::c_void,
        BufferLength: DWORD,
    ) -> DWORD;
}
extern "C" {
    #[doc = " <summary>"]
    #[doc = " Configures or sets a PCAN Channel value"]
    #[doc = " </summary>"]
    #[doc = " <remarks>Parameters can be present or not according with the kind"]
    #[doc = " of Hardware (PCAN Channel) being used. If a parameter is not available,"]
    #[doc = " a PCAN_ERROR_ILLPARAMTYPE error will be returned</remarks>"]
    #[doc = " <param name=\"Channel\">\"The handle of a PCAN Channel\"</param>"]
    #[doc = " <param name=\"Parameter\">\"The TPCANParameter parameter to set\"</param>"]
    #[doc = " <param name=\"Buffer\">\"Buffer with the value to be set\"</param>"]
    #[doc = " <param name=\"BufferLength\">\"Size in bytes of the buffer\"</param>"]
    #[doc = " <returns>\"A TPCANStatus error code\"</returns>"]
    pub fn CAN_SetValue(
        Channel: WORD,
        Parameter: BYTE,
        Buffer: *mut ::std::os::raw::c_void,
        BufferLength: DWORD,
    ) -> DWORD;
}
extern "C" {
    #[doc = " <summary>"]
    #[doc = " Returns a descriptive text of a given TPCANStatus error"]
    #[doc = " code, in any desired language"]
    #[doc = " </summary>"]
    #[doc = " <remarks>The current languages available for translation are:"]
    #[doc = " Neutral (0x00), German (0x07), English (0x09), Spanish (0x0A),"]
    #[doc = " Italian (0x10) and French (0x0C)</remarks>"]
    #[doc = " <param name=\"Error\">\"A TPCANStatus error code\"</param>"]
    #[doc = " <param name=\"Language\">\"Indicates a 'Primary language ID'\"</param>"]
    #[doc = " <param name=\"Buffer\">\"Buffer for a null terminated char array\"</param>"]
    #[doc = " <returns>\"A TPCANStatus error code\"</returns>"]
    pub fn CAN_GetErrorText(Error: DWORD, Language: WORD, Buffer: LPSTR) -> DWORD;
}
